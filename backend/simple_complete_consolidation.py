#!/usr/bin/env python3
"""
Simple Complete Consolidation Script
Merges ALL code from the three files with minimal processing to preserve everything.
"""

import os

def simple_consolidate():
    """Simple concatenation with proper headers and conflict resolution."""
    
    files_to_merge = [
        ("backend/analyzer.py", "ANALYZER.PY - ADVANCED ISSUE MANAGEMENT"),
        ("backend/api.py", "API.PY - FASTAPI WEB SERVICE"), 
        ("backend/comprehensive_analysis.py", "COMPREHENSIVE_ANALYSIS.PY - DEEP ANALYSIS")
    ]
    
    output_file = "backend/consolidated_api_complete.py"
    
    print("🔄 Starting simple complete consolidation...")
    
    with open(output_file, 'w', encoding='utf-8') as outf:
        # Write header
        outf.write('''#!/usr/bin/env python3
"""
COMPLETE CONSOLIDATED CODEBASE ANALYTICS API

This file contains ALL code from:
- analyzer.py (2,136 lines) - Advanced issue management and transaction support
- api.py (1,212 lines) - FastAPI web service with metrics calculation
- comprehensive_analysis.py (736 lines) - Deep codebase analysis using Codegen SDK

Total original lines: 4,084

Features:
✅ Complete dead code detection and analysis
✅ Advanced issue management with filtering and categorization  
✅ Comprehensive metrics (complexity, maintainability, volume)
✅ FastAPI web interface with all endpoints
✅ Multiple output formats (JSON, HTML, console, web)
✅ Interactive codebase tree and symbol analysis
✅ Git commit analysis and repository structure
✅ Parameter validation and type annotation checking
✅ Circular dependency detection
✅ Implementation error detection
✅ Modal deployment support

Generated by simple_complete_consolidation.py
"""

''')
        
        # Process each file
        for file_path, description in files_to_merge:
            if os.path.exists(file_path):
                print(f"📄 Processing {file_path}...")
                
                with open(file_path, 'r', encoding='utf-8') as inf:
                    content = inf.read()
                
                # Write section header
                outf.write(f'''
# {'=' * 80}
# {description}
# {'=' * 80}

''')
                
                # Process content to handle conflicts
                lines = content.split('\n')
                processed_lines = []
                skip_until_imports_end = False
                
                for i, line in enumerate(lines):
                    # Skip shebang from non-first files
                    if line.startswith('#!') and file_path != files_to_merge[0][0]:
                        continue
                    
                    # Skip module docstring from non-first files  
                    if (line.strip().startswith('"""') or line.strip().startswith("'''")) and i < 20:
                        if file_path != files_to_merge[0][0]:
                            # Skip until end of docstring
                            quote_type = line.strip()[:3]
                            if line.strip().count(quote_type) < 2:  # Multi-line docstring
                                skip_until_imports_end = True
                            continue
                    
                    if skip_until_imports_end:
                        if line.strip().endswith('"""') or line.strip().endswith("'''"):
                            skip_until_imports_end = False
                        continue
                    
                    # Handle duplicate class names
                    if 'class IssueSeverity' in line and 'comprehensive_analysis.py' in file_path:
                        line = line.replace('class IssueSeverity', 'class ComprehensiveIssueSeverity')
                    elif 'class Issue' in line and 'comprehensive_analysis.py' in file_path:
                        line = line.replace('class Issue', 'class ComprehensiveIssue')
                    
                    # Handle duplicate function names (top-level only)
                    if line.strip().startswith('def calculate_cyclomatic_complexity') and 'api.py' in file_path:
                        line = line.replace('def calculate_cyclomatic_complexity', 'def api_calculate_cyclomatic_complexity')
                    
                    processed_lines.append(line)
                
                # Write processed content
                outf.write('\n'.join(processed_lines))
                outf.write('\n\n')
                
                print(f"  ✅ Added {len(processed_lines)} lines from {file_path}")
            else:
                print(f"  ❌ File not found: {file_path}")
        
        # Add unified main block
        outf.write('''
# ================================================================================
# UNIFIED MAIN EXECUTION BLOCK
# ================================================================================

if __name__ == "__main__":
    import argparse
    import sys
    
    parser = argparse.ArgumentParser(
        description="Complete Consolidated Codebase Analytics API",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Available modes:
  api        - Start FastAPI web server (default)
  analyze    - Run comprehensive analysis using CodebaseAnalyzer
  cli        - Command line interface using ComprehensiveAnalyzer  
  html       - Generate HTML report
        """
    )
    
    parser.add_argument("--mode", choices=["api", "analyze", "cli", "html"], default="api")
    parser.add_argument("--repo", help="Repository path or URL")
    parser.add_argument("--port", type=int, default=8000, help="API server port")
    parser.add_argument("--output", help="Output file path")
    parser.add_argument("--format", choices=["json", "html", "console"], default="console")
    
    args = parser.parse_args()
    
    if args.mode == "api":
        try:
            import uvicorn
            print(f"🚀 Starting Complete Analytics API on http://localhost:{args.port}")
            print(f"📚 Documentation: http://localhost:{args.port}/docs")
            
            # Try to find the FastAPI app
            if 'fastapi_app' in globals():
                uvicorn.run(fastapi_app, host="0.0.0.0", port=args.port)
            elif 'app' in globals():
                uvicorn.run(app, host="0.0.0.0", port=args.port)
            else:
                print("❌ FastAPI app not found. Check consolidation.")
                sys.exit(1)
        except ImportError:
            print("❌ FastAPI/uvicorn not available. Install with: pip install fastapi uvicorn")
            sys.exit(1)
    
    elif args.mode == "analyze":
        if not args.repo:
            print("❌ --repo required for analysis mode")
            sys.exit(1)
        
        try:
            print(f"🔍 Analyzing {args.repo} using CodebaseAnalyzer...")
            analyzer = CodebaseAnalyzer(repo_path=args.repo)
            result = analyzer.analyze()
            
            if args.output:
                analyzer.save_results(args.output)
                print(f"✅ Results saved to {args.output}")
            else:
                analyzer._print_console_report()
        except Exception as e:
            print(f"❌ Analysis failed: {e}")
            import traceback
            traceback.print_exc()
            sys.exit(1)
    
    elif args.mode == "cli":
        if not args.repo:
            print("❌ --repo required for CLI mode")
            sys.exit(1)
        
        try:
            print(f"🔍 Analyzing {args.repo} using ComprehensiveAnalyzer...")
            comp_analyzer = ComprehensiveAnalyzer(args.repo)
            result = comp_analyzer.analyze()
            comp_analyzer._print_report(result)
        except Exception as e:
            print(f"❌ CLI analysis failed: {e}")
            import traceback
            traceback.print_exc()
            sys.exit(1)
    
    elif args.mode == "html":
        if not args.repo:
            print("❌ --repo required for HTML mode")
            sys.exit(1)
        
        try:
            print(f"🔍 Generating HTML report for {args.repo}...")
            analyzer = CodebaseAnalyzer(repo_path=args.repo)
            analyzer.analyze()
            output_file = args.output or "analysis_report.html"
            analyzer._generate_html_report(output_file)
            print(f"✅ HTML report generated: {output_file}")
        except Exception as e:
            print(f"❌ HTML generation failed: {e}")
            import traceback
            traceback.print_exc()
            sys.exit(1)
''')
    
    # Validate the result
    print("🧪 Validating consolidated file...")
    
    with open(output_file, 'r') as f:
        lines = f.readlines()
        line_count = len(lines)
    
    print(f"📊 Consolidated file: {line_count} lines")
    
    # Check syntax
    try:
        with open(output_file, 'r') as f:
            compile(f.read(), output_file, 'exec')
        print("✅ Syntax validation passed")
        syntax_ok = True
    except SyntaxError as e:
        print(f"❌ Syntax error: {e}")
        syntax_ok = False
    
    print("\n" + "=" * 60)
    print("📈 SIMPLE CONSOLIDATION SUMMARY")
    print("=" * 60)
    print(f"📁 Files processed: {len(files_to_merge)}")
    print(f"📄 Final consolidated lines: {line_count}")
    print(f"✅ Syntax validation: {'PASSED' if syntax_ok else 'FAILED'}")
    
    if syntax_ok:
        print(f"\n🎉 SUCCESS! Complete consolidation created: {output_file}")
        print("🚀 All functionality from all three files preserved!")
    else:
        print(f"\n⚠️ Consolidation completed with syntax errors: {output_file}")
    
    return syntax_ok

if __name__ == "__main__":
    success = simple_consolidate()
    exit(0 if success else 1)

