#!/usr/bin/env python3
"""
Simple Complete Consolidation Script
Merges ALL code from the three files with minimal processing to preserve everything.
"""

import os

def simple_consolidate():
    """Simple concatenation with proper headers and conflict resolution."""
    
    files_to_merge = [
        ("backend/analyzer.py", "ANALYZER.PY - ADVANCED ISSUE MANAGEMENT"),
        ("backend/api.py", "API.PY - FASTAPI WEB SERVICE"), 
        ("backend/comprehensive_analysis.py", "COMPREHENSIVE_ANALYSIS.PY - DEEP ANALYSIS")
    ]
    
    output_file = "backend/consolidated_api_complete.py"
    
    print("ðŸ”„ Starting simple complete consolidation...")
    
    with open(output_file, 'w', encoding='utf-8') as outf:
        # Write header
        outf.write('''#!/usr/bin/env python3
"""
COMPLETE CONSOLIDATED CODEBASE ANALYTICS API

This file contains ALL code from:
- analyzer.py (2,136 lines) - Advanced issue management and transaction support
- api.py (1,212 lines) - FastAPI web service with metrics calculation
- comprehensive_analysis.py (736 lines) - Deep codebase analysis using Codegen SDK

Total original lines: 4,084

Features:
âœ… Complete dead code detection and analysis
âœ… Advanced issue management with filtering and categorization  
âœ… Comprehensive metrics (complexity, maintainability, volume)
âœ… FastAPI web interface with all endpoints
âœ… Multiple output formats (JSON, HTML, console, web)
âœ… Interactive codebase tree and symbol analysis
âœ… Git commit analysis and repository structure
âœ… Parameter validation and type annotation checking
âœ… Circular dependency detection
âœ… Implementation error detection
âœ… Modal deployment support

Generated by simple_complete_consolidation.py
"""

''')
        
        # Process each file
        for file_path, description in files_to_merge:
            if os.path.exists(file_path):
                print(f"ðŸ“„ Processing {file_path}...")
                
                with open(file_path, 'r', encoding='utf-8') as inf:
                    content = inf.read()
                
                # Write section header
                outf.write(f'''
# {'=' * 80}
# {description}
# {'=' * 80}

''')
                
                # Process content to handle conflicts
                lines = content.split('\n')
                processed_lines = []
                skip_until_imports_end = False
                
                for i, line in enumerate(lines):
                    # Skip shebang from non-first files
                    if line.startswith('#!') and file_path != files_to_merge[0][0]:
                        continue
                    
                    # Skip module docstring from non-first files  
                    if (line.strip().startswith('"""') or line.strip().startswith("'''")) and i < 20:
                        if file_path != files_to_merge[0][0]:
                            # Skip until end of docstring
                            quote_type = line.strip()[:3]
                            if line.strip().count(quote_type) < 2:  # Multi-line docstring
                                skip_until_imports_end = True
                            continue
                    
                    if skip_until_imports_end:
                        if line.strip().endswith('"""') or line.strip().endswith("'''"):
                            skip_until_imports_end = False
                        continue
                    
                    # Handle duplicate class names
                    if 'class IssueSeverity' in line and 'comprehensive_analysis.py' in file_path:
                        line = line.replace('class IssueSeverity', 'class ComprehensiveIssueSeverity')
                    elif 'class Issue' in line and 'comprehensive_analysis.py' in file_path:
                        line = line.replace('class Issue', 'class ComprehensiveIssue')
                    
                    # Handle duplicate function names (top-level only)
                    if line.strip().startswith('def calculate_cyclomatic_complexity') and 'api.py' in file_path:
                        line = line.replace('def calculate_cyclomatic_complexity', 'def api_calculate_cyclomatic_complexity')
                    
                    processed_lines.append(line)
                
                # Write processed content
                outf.write('\n'.join(processed_lines))
                outf.write('\n\n')
                
                print(f"  âœ… Added {len(processed_lines)} lines from {file_path}")
            else:
                print(f"  âŒ File not found: {file_path}")
        
        # Add unified main block
        outf.write('''
# ================================================================================
# UNIFIED MAIN EXECUTION BLOCK
# ================================================================================

if __name__ == "__main__":
    import argparse
    import sys
    
    parser = argparse.ArgumentParser(
        description="Complete Consolidated Codebase Analytics API",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Available modes:
  api        - Start FastAPI web server (default)
  analyze    - Run comprehensive analysis using CodebaseAnalyzer
  cli        - Command line interface using ComprehensiveAnalyzer  
  html       - Generate HTML report
        """
    )
    
    parser.add_argument("--mode", choices=["api", "analyze", "cli", "html"], default="api")
    parser.add_argument("--repo", help="Repository path or URL")
    parser.add_argument("--port", type=int, default=8000, help="API server port")
    parser.add_argument("--output", help="Output file path")
    parser.add_argument("--format", choices=["json", "html", "console"], default="console")
    
    args = parser.parse_args()
    
    if args.mode == "api":
        try:
            import uvicorn
            print(f"ðŸš€ Starting Complete Analytics API on http://localhost:{args.port}")
            print(f"ðŸ“š Documentation: http://localhost:{args.port}/docs")
            
            # Try to find the FastAPI app
            if 'fastapi_app' in globals():
                uvicorn.run(fastapi_app, host="0.0.0.0", port=args.port)
            elif 'app' in globals():
                uvicorn.run(app, host="0.0.0.0", port=args.port)
            else:
                print("âŒ FastAPI app not found. Check consolidation.")
                sys.exit(1)
        except ImportError:
            print("âŒ FastAPI/uvicorn not available. Install with: pip install fastapi uvicorn")
            sys.exit(1)
    
    elif args.mode == "analyze":
        if not args.repo:
            print("âŒ --repo required for analysis mode")
            sys.exit(1)
        
        try:
            print(f"ðŸ” Analyzing {args.repo} using CodebaseAnalyzer...")
            analyzer = CodebaseAnalyzer(repo_path=args.repo)
            result = analyzer.analyze()
            
            if args.output:
                analyzer.save_results(args.output)
                print(f"âœ… Results saved to {args.output}")
            else:
                analyzer._print_console_report()
        except Exception as e:
            print(f"âŒ Analysis failed: {e}")
            import traceback
            traceback.print_exc()
            sys.exit(1)
    
    elif args.mode == "cli":
        if not args.repo:
            print("âŒ --repo required for CLI mode")
            sys.exit(1)
        
        try:
            print(f"ðŸ” Analyzing {args.repo} using ComprehensiveAnalyzer...")
            comp_analyzer = ComprehensiveAnalyzer(args.repo)
            result = comp_analyzer.analyze()
            comp_analyzer._print_report(result)
        except Exception as e:
            print(f"âŒ CLI analysis failed: {e}")
            import traceback
            traceback.print_exc()
            sys.exit(1)
    
    elif args.mode == "html":
        if not args.repo:
            print("âŒ --repo required for HTML mode")
            sys.exit(1)
        
        try:
            print(f"ðŸ” Generating HTML report for {args.repo}...")
            analyzer = CodebaseAnalyzer(repo_path=args.repo)
            analyzer.analyze()
            output_file = args.output or "analysis_report.html"
            analyzer._generate_html_report(output_file)
            print(f"âœ… HTML report generated: {output_file}")
        except Exception as e:
            print(f"âŒ HTML generation failed: {e}")
            import traceback
            traceback.print_exc()
            sys.exit(1)
''')
    
    # Validate the result
    print("ðŸ§ª Validating consolidated file...")
    
    with open(output_file, 'r') as f:
        lines = f.readlines()
        line_count = len(lines)
    
    print(f"ðŸ“Š Consolidated file: {line_count} lines")
    
    # Check syntax
    try:
        with open(output_file, 'r') as f:
            compile(f.read(), output_file, 'exec')
        print("âœ… Syntax validation passed")
        syntax_ok = True
    except SyntaxError as e:
        print(f"âŒ Syntax error: {e}")
        syntax_ok = False
    
    print("\n" + "=" * 60)
    print("ðŸ“ˆ SIMPLE CONSOLIDATION SUMMARY")
    print("=" * 60)
    print(f"ðŸ“ Files processed: {len(files_to_merge)}")
    print(f"ðŸ“„ Final consolidated lines: {line_count}")
    print(f"âœ… Syntax validation: {'PASSED' if syntax_ok else 'FAILED'}")
    
    if syntax_ok:
        print(f"\nðŸŽ‰ SUCCESS! Complete consolidation created: {output_file}")
        print("ðŸš€ All functionality from all three files preserved!")
    else:
        print(f"\nâš ï¸ Consolidation completed with syntax errors: {output_file}")
    
    return syntax_ok

if __name__ == "__main__":
    success = simple_consolidate()
    exit(0 if success else 1)

