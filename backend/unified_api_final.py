#!/usr/bin/env python3
"""
Unified Codebase Analytics API

This file consolidates functionality from:
- comprehensive_analysis.py: Deep codebase analysis with Codegen SDK
- api.py: FastAPI web service with metrics calculation
- analyzer.py: Advanced issue management and transaction support

Features:
- Comprehensive codebase analysis
- REST API endpoints for web access
- Advanced issue detection and management
- Multiple output formats (JSON, HTML, console)
- CLI and web interfaces

Generated by enhanced_consolidation.py with manual refinements
"""

# ========================================
# IMPORTS
# ========================================

import argparse
import json
import logging
import math
import os
import re
import subprocess
import sys
import tempfile
import time
import hashlib
import socket
import traceback
from collections import Counter
from dataclasses import asdict, dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from pathlib import Path
from typing import Dict, List, Optional, Any, Set, Tuple, Union

# Third-party imports (with graceful fallbacks)
try:
    import uvicorn
    from fastapi import FastAPI, HTTPException
    from fastapi.middleware.cors import CORSMiddleware
    from pydantic import BaseModel
    FASTAPI_AVAILABLE = True
except ImportError:
    FASTAPI_AVAILABLE = False
    print("Warning: FastAPI not available. API mode will be disabled.")

try:
    import modal
    MODAL_AVAILABLE = True
except ImportError:
    MODAL_AVAILABLE = False
    print("Warning: Modal not available. Cloud deployment will be disabled.")

try:
    import networkx as nx
    NETWORKX_AVAILABLE = True
except ImportError:
    NETWORKX_AVAILABLE = False
    print("Warning: NetworkX not available. Graph analysis will be limited.")

try:
    import requests
    REQUESTS_AVAILABLE = True
except ImportError:
    REQUESTS_AVAILABLE = False
    print("Warning: Requests not available. GitHub API features will be disabled.")

# Codegen SDK imports (with graceful fallbacks)
try:
    from codegen.sdk.core.codebase import Codebase
    from codegen.sdk.core.file import SourceFile
    from codegen.sdk.core.function import Function
    from codegen.sdk.core.class_definition import Class
    from codegen.sdk.core.symbol import Symbol
    from codegen.sdk.core.import_resolution import Import
    from codegen.sdk.enums import EdgeType, SymbolType
    CODEGEN_SDK_AVAILABLE = True
except ImportError:
    CODEGEN_SDK_AVAILABLE = False
    print("Warning: Codegen SDK not available. Advanced analysis features will be limited.")

# ========================================
# FASTAPI APP INITIALIZATION
# ========================================

if FASTAPI_AVAILABLE:
    fastapi_app = FastAPI(
        title="Unified Codebase Analytics API", 
        version="1.0.0",
        description="Consolidated codebase analysis with multiple interfaces"
    )
    
    fastapi_app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

# ========================================
# CONSOLIDATED CLASSES
# ========================================

class IssueType:
    """Types of issues that can be detected."""
    UNUSED_FUNCTION = 'Unused function'
    UNUSED_CLASS = 'Unused class'
    UNUSED_IMPORT = 'Unused import'
    UNUSED_PARAMETER = 'Unused parameter'
    PARAMETER_MISMATCH = 'Parameter mismatch'
    MISSING_TYPE_ANNOTATION = 'Missing type annotation'
    CIRCULAR_DEPENDENCY = 'Circular dependency'
    IMPLEMENTATION_ERROR = 'Implementation error'
    EMPTY_FUNCTION = 'Empty function'
    UNREACHABLE_CODE = 'Unreachable code'

class IssueSeverity(str, Enum):
    """Severity levels for issues."""
    CRITICAL = 'critical'
    ERROR = 'error'
    WARNING = 'warning'
    INFO = 'info'

class AnalysisType(str, Enum):
    """Types of analysis that can be performed."""
    CODEBASE = "codebase"
    PR = "pr"
    COMPARISON = "comparison"
    CODE_QUALITY = "code_quality"
    DEPENDENCY = "dependency"
    SECURITY = "security"
    PERFORMANCE = "performance"
    TYPE_CHECKING = "type_checking"
    COMPREHENSIVE = "comprehensive"

class IssueCategory(str, Enum):
    """Categories of issues that can be detected."""
    DEAD_CODE = "dead_code"
    COMPLEXITY = "complexity"
    STYLE_ISSUE = "style_issue"
    DOCUMENTATION = "documentation"
    TYPE_ERROR = "type_error"
    PARAMETER_MISMATCH = "parameter_mismatch"
    RETURN_TYPE_ERROR = "return_type_error"
    IMPLEMENTATION_ERROR = "implementation_error"
    MISSING_IMPLEMENTATION = "missing_implementation"
    IMPORT_ERROR = "import_error"
    DEPENDENCY_CYCLE = "dependency_cycle"
    MODULE_COUPLING = "module_coupling"
    API_CHANGE = "api_change"
    API_USAGE_ERROR = "api_usage_error"
    SECURITY_VULNERABILITY = "security_vulnerability"
    PERFORMANCE_ISSUE = "performance_issue"

@dataclass
class CodeLocation:
    """Location of an issue in code."""
    file: str
    line: Optional[int] = None
    column: Optional[int] = None
    end_line: Optional[int] = None
    end_column: Optional[int] = None

    def __str__(self) -> str:
        if self.line is not None:
            if self.column is not None:
                return f"{self.file}:{self.line}:{self.column}"
            return f"{self.file}:{self.line}"
        return self.file

@dataclass
class Issue:
    """Represents an issue found during analysis."""
    message: str
    severity: IssueSeverity
    location: CodeLocation
    category: Optional[IssueCategory] = None
    analysis_type: Optional[AnalysisType] = None
    symbol: Optional[str] = None
    code: Optional[str] = None
    suggestion: Optional[str] = None
    related_symbols: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)
    id: Optional[str] = None

    def __post_init__(self):
        if self.id is None:
            hash_input = f"{self.location.file}:{self.location.line}:{self.message}"
            self.id = hashlib.md5(hash_input.encode()).hexdigest()[:12]

if FASTAPI_AVAILABLE:
    class RepoRequest(BaseModel):
        repo_url: str

    class AnalysisResponse(BaseModel):
        repo_url: str
        description: str
        num_files: int
        num_functions: int
        num_classes: int
        issues: List[Dict[str, Any]]
        summary: Dict[str, Any]

# ========================================
# CORE ANALYSIS FUNCTIONS
# ========================================

def analyze_codebase_simple(repo_path: str) -> Dict[str, Any]:
    """
    Simple codebase analysis that works without Codegen SDK.
    Analyzes Python files using AST parsing.
    """
    import ast
    from pathlib import Path
    
    results = {
        "repo_path": repo_path,
        "files_analyzed": 0,
        "total_functions": 0,
        "total_classes": 0,
        "issues": [],
        "analysis_time": datetime.now().isoformat()
    }
    
    if not os.path.exists(repo_path):
        results["error"] = f"Repository path does not exist: {repo_path}"
        return results
    
    python_files = list(Path(repo_path).rglob("*.py"))
    results["files_analyzed"] = len(python_files)
    
    for file_path in python_files:
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            tree = ast.parse(content)
            
            # Count functions and classes
            for node in ast.walk(tree):
                if isinstance(node, ast.FunctionDef):
                    results["total_functions"] += 1
                    
                    # Check for potential issues
                    if len(node.body) == 1 and isinstance(node.body[0], ast.Pass):
                        results["issues"].append({
                            "type": IssueType.EMPTY_FUNCTION,
                            "severity": IssueSeverity.WARNING.value,
                            "message": f"Empty function: {node.name}",
                            "file": str(file_path),
                            "line": node.lineno
                        })
                    
                elif isinstance(node, ast.ClassDef):
                    results["total_classes"] += 1
                    
        except Exception as e:
            results["issues"].append({
                "type": "PARSE_ERROR",
                "severity": IssueSeverity.ERROR.value,
                "message": f"Failed to parse {file_path}: {str(e)}",
                "file": str(file_path),
                "line": 1
            })
    
    return results

def analyze_codebase_advanced(repo_path_or_url: str) -> Dict[str, Any]:
    """
    Advanced codebase analysis using Codegen SDK if available.
    Falls back to simple analysis if SDK is not available.
    """
    if not CODEGEN_SDK_AVAILABLE:
        print("⚠️ Codegen SDK not available, using simple analysis")
        return analyze_codebase_simple(repo_path_or_url)
    
    try:
        # Initialize codebase
        if repo_path_or_url.startswith(("http://", "https://")):
            # Extract repo name for GitHub URLs
            parts = repo_path_or_url.rstrip('/').split('/')
            repo_name = f"{parts[-2]}/{parts[-1]}"
            codebase = Codebase.from_repo(repo_full_name=repo_name)
        else:
            codebase = Codebase(repo_path_or_url)
        
        # Perform analysis
        results = {
            "repo_path": repo_path_or_url,
            "files_analyzed": len(list(codebase.files)),
            "total_functions": len(list(codebase.functions)),
            "total_classes": len(list(codebase.classes)),
            "issues": [],
            "analysis_time": datetime.now().isoformat()
        }
        
        # Analyze for unused functions
        for func in codebase.functions:
            if not func.usages:
                results["issues"].append({
                    "type": IssueType.UNUSED_FUNCTION,
                    "severity": IssueSeverity.WARNING.value,
                    "message": f"Unused function: {func.name}",
                    "file": func.file.path if hasattr(func, 'file') else "unknown",
                    "line": func.line if hasattr(func, 'line') else 0
                })
        
        return results
        
    except Exception as e:
        print(f"❌ Advanced analysis failed: {e}")
        return analyze_codebase_simple(repo_path_or_url)

def calculate_cyclomatic_complexity_simple(function_source: str) -> int:
    """
    Calculate cyclomatic complexity using AST parsing.
    """
    import ast
    
    try:
        tree = ast.parse(function_source)
        complexity = 1  # Base complexity
        
        for node in ast.walk(tree):
            if isinstance(node, (ast.If, ast.While, ast.For, ast.AsyncFor)):
                complexity += 1
            elif isinstance(node, ast.ExceptHandler):
                complexity += 1
            elif isinstance(node, ast.BoolOp):
                complexity += len(node.values) - 1
                
        return complexity
    except:
        return 1

def get_monthly_commits_simple(repo_path: str) -> Dict[str, int]:
    """
    Get monthly commit counts using git commands.
    """
    if not os.path.exists(os.path.join(repo_path, '.git')):
        return {}
    
    try:
        end_date = datetime.now()
        start_date = end_date - timedelta(days=365)
        
        cmd = [
            "git", "-C", repo_path, "log",
            f"--since={start_date.strftime('%Y-%m-%d')}",
            f"--until={end_date.strftime('%Y-%m-%d')}",
            "--format=%aI"
        ]
        
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        commit_dates = result.stdout.strip().split("\n")
        
        monthly_counts = {}
        for date_str in commit_dates:
            if date_str:
                commit_date = datetime.fromisoformat(date_str.strip())
                month_key = commit_date.strftime("%Y-%m")
                monthly_counts[month_key] = monthly_counts.get(month_key, 0) + 1
        
        return monthly_counts
        
    except Exception as e:
        print(f"Error getting commit history: {e}")
        return {}

# ========================================
# API ENDPOINTS
# ========================================

if FASTAPI_AVAILABLE:
    @fastapi_app.post("/analyze_repo")
    async def analyze_repo(request: RepoRequest) -> AnalysisResponse:
        """Analyze a repository and return comprehensive results."""
        try:
            results = analyze_codebase_advanced(request.repo_url)
            
            return AnalysisResponse(
                repo_url=request.repo_url,
                description=f"Analysis of {request.repo_url}",
                num_files=results["files_analyzed"],
                num_functions=results["total_functions"],
                num_classes=results["total_classes"],
                issues=results["issues"],
                summary={
                    "total_issues": len(results["issues"]),
                    "analysis_time": results["analysis_time"]
                }
            )
        except Exception as e:
            raise HTTPException(status_code=500, detail=str(e))

    @fastapi_app.get("/health")
    async def health_check():
        """Health check endpoint."""
        return {
            "status": "healthy",
            "timestamp": datetime.now().isoformat(),
            "features": {
                "codegen_sdk": CODEGEN_SDK_AVAILABLE,
                "networkx": NETWORKX_AVAILABLE,
                "requests": REQUESTS_AVAILABLE,
                "modal": MODAL_AVAILABLE
            }
        }

    @fastapi_app.get("/")
    async def root():
        """Root endpoint with API information."""
        return {
            "name": "Unified Codebase Analytics API",
            "version": "1.0.0",
            "description": "Consolidated codebase analysis with multiple interfaces",
            "endpoints": {
                "analyze": "/analyze_repo",
                "health": "/health",
                "docs": "/docs",
                "redoc": "/redoc"
            }
        }

# ========================================
# CLI INTERFACE
# ========================================

def run_cli_analysis(repo_path: str, output_format: str = "console"):
    """Run analysis in CLI mode."""
    print(f"🔍 Analyzing repository: {repo_path}")
    
    results = analyze_codebase_advanced(repo_path)
    
    if output_format == "json":
        print(json.dumps(results, indent=2))
    elif output_format == "console":
        print(f"\n📊 Analysis Results:")
        print(f"  📁 Files analyzed: {results['files_analyzed']}")
        print(f"  ⚙️ Functions found: {results['total_functions']}")
        print(f"  🏛️ Classes found: {results['total_classes']}")
        print(f"  ⚠️ Issues found: {len(results['issues'])}")
        
        if results['issues']:
            print(f"\n🔍 Issues:")
            for i, issue in enumerate(results['issues'][:10], 1):
                print(f"  {i}. [{issue['severity']}] {issue['message']} ({issue['file']}:{issue.get('line', '?')})")
            
            if len(results['issues']) > 10:
                print(f"  ... and {len(results['issues']) - 10} more issues")
    
    print(f"\n✅ Analysis complete! ({results['analysis_time']})")

# ========================================
# MAIN EXECUTION
# ========================================

def find_available_port(start_port: int = 8000, max_port: int = 8100) -> int:
    """Find an available port starting from start_port."""
    for port in range(start_port, max_port):
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.bind(("0.0.0.0", port))
                return port
        except OSError:
            continue
    raise RuntimeError(f"No available ports found between {start_port} and {max_port}")

def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Unified Codebase Analytics API",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s --mode api                    # Start web API server
  %(prog)s --mode cli --repo ./my-repo   # Analyze repository via CLI
  %(prog)s --mode analyze --repo ./repo  # Direct analysis with detailed output
        """
    )
    
    parser.add_argument(
        "--mode", 
        choices=["api", "cli", "analyze"],
        default="api",
        help="Run mode: api (web server), cli (command line), analyze (direct analysis)"
    )
    parser.add_argument(
        "--repo",
        help="Repository URL or path for analysis"
    )
    parser.add_argument(
        "--port",
        type=int,
        default=8000,
        help="Port for API server (default: 8000)"
    )
    parser.add_argument(
        "--output",
        choices=["console", "json"],
        default="console",
        help="Output format for CLI mode"
    )
    
    args = parser.parse_args()
    
    if args.mode == "api":
        if not FASTAPI_AVAILABLE:
            print("❌ FastAPI not available. Please install with: pip install fastapi uvicorn")
            sys.exit(1)
        
        port = find_available_port(args.port)
        print(f"🚀 Starting Unified Codebase Analytics API on http://localhost:{port}")
        print(f"📚 API documentation available at http://localhost:{port}/docs")
        print(f"🔍 Interactive API explorer at http://localhost:{port}/redoc")
        print(f"💡 Health check: http://localhost:{port}/health")
        
        uvicorn.run(fastapi_app, host="0.0.0.0", port=port)
        
    elif args.mode in ["cli", "analyze"]:
        if not args.repo:
            print("❌ --repo is required for CLI and analyze modes")
            parser.print_help()
            sys.exit(1)
        
        try:
            run_cli_analysis(args.repo, args.output)
        except Exception as e:
            print(f"❌ Analysis failed: {e}")
            if args.output == "json":
                print(json.dumps({"error": str(e)}))
            sys.exit(1)

if __name__ == "__main__":
    main()

